package e2e

import (
	"github.com/onsi/ginkgo/v2"
	"github.com/onsi/gomega"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/utils/ptr"
	"sigs.k8s.io/controller-runtime/pkg/client"
	jobsetconsts "sigs.k8s.io/jobset/pkg/constants"

	trainer "github.com/kubeflow/trainer/v2/pkg/apis/trainer/v1alpha1"
	"github.com/kubeflow/trainer/v2/pkg/constants"
	testingutil "github.com/kubeflow/trainer/v2/pkg/util/testing"
	"github.com/kubeflow/trainer/v2/test/util"

	_ "embed"
)

const (
	torchRuntime     = "torch-distributed"
	deepSpeedRuntime = "deepspeed-distributed"
	jaxRuntime       = "jax-distributed"
)

//go:embed testdata/progress.py
var progressScript string

var _ = ginkgo.Describe("TrainJob e2e", func() {
	// Each test runs in a separate namespace.
	var ns *corev1.Namespace

	// Create test namespace before each test.
	ginkgo.BeforeEach(func() {
		ns = &corev1.Namespace{
			ObjectMeta: metav1.ObjectMeta{
				GenerateName: "e2e-",
			},
		}
		gomega.Expect(k8sClient.Create(ctx, ns)).To(gomega.Succeed())

		// Wait for namespace to exist before proceeding with test.
		gomega.Eventually(func(g gomega.Gomega) {
			g.Expect(k8sClient.Get(ctx, client.ObjectKeyFromObject(ns), ns)).Should(gomega.Succeed())
		}, util.TimeoutE2E, util.Interval).Should(gomega.Succeed())
	})

	// Delete test namespace after each test.
	ginkgo.AfterEach(func() {
		// Delete test namespace after each test.
		gomega.Expect(k8sClient.Delete(ctx, ns)).To(gomega.Succeed())
	})

	// These tests create TrainJob that reference supported runtime without any additional changes.
	ginkgo.When("Creating TrainJob to perform the PyTorch workload", func() {
		// Verify the `torch-distributed` ClusterTrainingRuntime.
		ginkgo.It("should create TrainJob with PyTorch runtime reference", func() {
			// Create a TrainJob.
			trainJob := testingutil.MakeTrainJobWrapper(ns.Name, "e2e-test-torch").
				RuntimeRef(trainer.SchemeGroupVersion.WithKind(trainer.ClusterTrainingRuntimeKind), torchRuntime).
				Obj()

			ginkgo.By("Create a TrainJob with torch-distributed runtime reference", func() {
				gomega.Expect(k8sClient.Create(ctx, trainJob)).Should(gomega.Succeed())
			})

			// Wait for jobs to become active
			ginkgo.By("Wait for TrainJob jobs to become active", func() {
				gomega.Eventually(func(g gomega.Gomega) {
					gotTrainJob := &trainer.TrainJob{}
					g.Expect(k8sClient.Get(ctx, client.ObjectKeyFromObject(trainJob), gotTrainJob)).Should(gomega.Succeed())
					g.Expect(gotTrainJob.Status.JobsStatus).Should(gomega.BeComparableTo([]trainer.JobStatus{
						{
							Name:      constants.Node,
							Ready:     ptr.To(int32(0)),
							Succeeded: ptr.To(int32(0)),
							Failed:    ptr.To(int32(0)),
							Active:    ptr.To(int32(1)),
							Suspended: ptr.To(int32(0)),
						},
					}, util.SortJobsStatus))
				}, util.TimeoutE2E, util.Interval).Should(gomega.Succeed())
			})

			// Wait for TrainJob to be in Succeeded status with all jobs succeeded.
			ginkgo.By("Wait for TrainJob to be in Succeeded status with all jobs succeeded", func() {
				gomega.Eventually(func(g gomega.Gomega) {
					gotTrainJob := &trainer.TrainJob{}
					g.Expect(k8sClient.Get(ctx, client.ObjectKeyFromObject(trainJob), gotTrainJob)).Should(gomega.Succeed())
					g.Expect(gotTrainJob.Status.Conditions).Should(gomega.BeComparableTo([]metav1.Condition{
						{
							Type:    trainer.TrainJobComplete,
							Status:  metav1.ConditionTrue,
							Reason:  jobsetconsts.AllJobsCompletedReason,
							Message: jobsetconsts.AllJobsCompletedMessage,
						},
					}, util.IgnoreConditions))
					g.Expect(gotTrainJob.Status.JobsStatus).Should(gomega.BeComparableTo([]trainer.JobStatus{
						{
							Name:      constants.Node,
							Ready:     ptr.To(int32(0)),
							Succeeded: ptr.To(int32(1)),
							Failed:    ptr.To(int32(0)),
							Active:    ptr.To(int32(0)),
							Suspended: ptr.To(int32(0)),
						},
					}, util.SortJobsStatus))
				}, util.TimeoutE2E, util.Interval).Should(gomega.Succeed())
			})
		})
	})

	ginkgo.When("Creating TrainJob to perform OpenMPI workload", func() {
		// Verify the `deepspeed-distributed` ClusterTrainingRuntime.
		ginkgo.It("should create TrainJob with DeepSpeed runtime reference", func() {
			// Create a TrainJob.
			trainJob := testingutil.MakeTrainJobWrapper(ns.Name, "e2e-test-deepspeed").
				RuntimeRef(trainer.SchemeGroupVersion.WithKind(trainer.ClusterTrainingRuntimeKind), deepSpeedRuntime).
				Obj()

			ginkgo.By("Create a TrainJob with deepspeed-distributed runtime reference", func() {
				gomega.Expect(k8sClient.Create(ctx, trainJob)).Should(gomega.Succeed())
			})

			// Wait for jobs to become active
			ginkgo.By("Wait for TrainJob jobs to become active", func() {
				gomega.Eventually(func(g gomega.Gomega) {
					gotTrainJob := &trainer.TrainJob{}
					g.Expect(k8sClient.Get(ctx, client.ObjectKeyFromObject(trainJob), gotTrainJob)).Should(gomega.Succeed())
					g.Expect(gotTrainJob.Status.JobsStatus).Should(gomega.BeComparableTo([]trainer.JobStatus{
						{
							Name:      constants.Launcher,
							Ready:     ptr.To(int32(0)),
							Succeeded: ptr.To(int32(0)),
							Failed:    ptr.To(int32(0)),
							Active:    ptr.To(int32(1)),
							Suspended: ptr.To(int32(0)),
						},
						{
							Name:      constants.Node,
							Ready:     ptr.To(int32(0)),
							Succeeded: ptr.To(int32(0)),
							Failed:    ptr.To(int32(0)),
							Active:    ptr.To(int32(1)),
							Suspended: ptr.To(int32(0)),
						},
					}, util.SortJobsStatus))
				}, util.TimeoutE2E, util.Interval).Should(gomega.Succeed())
			})

			// Wait for TrainJob to be in Succeeded status.
			ginkgo.By("Wait for TrainJob to be in Succeeded status", func() {
				gomega.Eventually(func(g gomega.Gomega) {
					gotTrainJob := &trainer.TrainJob{}
					g.Expect(k8sClient.Get(ctx, client.ObjectKeyFromObject(trainJob), gotTrainJob)).Should(gomega.Succeed())
					g.Expect(gotTrainJob.Status.Conditions).Should(gomega.BeComparableTo([]metav1.Condition{
						{
							Type:    trainer.TrainJobComplete,
							Status:  metav1.ConditionTrue,
							Reason:  jobsetconsts.AllJobsCompletedReason,
							Message: jobsetconsts.AllJobsCompletedMessage,
						},
					}, util.IgnoreConditions))
					g.Expect(gotTrainJob.Status.JobsStatus).Should(gomega.BeComparableTo([]trainer.JobStatus{
						{
							Name:      constants.Launcher,
							Ready:     ptr.To(int32(0)),
							Succeeded: ptr.To(int32(1)),
							Failed:    ptr.To(int32(0)),
							Active:    ptr.To(int32(0)),
							Suspended: ptr.To(int32(0)),
						},
						{
							Name:      constants.Node,
							Ready:     ptr.To(int32(0)),
							Succeeded: ptr.To(int32(0)),
							Failed:    ptr.To(int32(0)),
							Active:    ptr.To(int32(0)),
							Suspended: ptr.To(int32(0)),
						},
					}, util.SortJobsStatus))
				}, util.TimeoutE2E, util.Interval).Should(gomega.Succeed())
			})
		})
	})

	ginkgo.When("Creating TrainJob to perform JAX workload", func() {
		// Verify the `jax-distributed` ClusterTrainingRuntime.
		ginkgo.It("should create TrainJob with JAX runtime reference", func() {
			// Create a TrainJob.
			trainJob := testingutil.MakeTrainJobWrapper(ns.Name, "e2e-test-jax").
				RuntimeRef(trainer.SchemeGroupVersion.WithKind(trainer.ClusterTrainingRuntimeKind), jaxRuntime).
				Obj()

			ginkgo.By("Create a TrainJob with jax-distributed runtime reference", func() {
				gomega.Expect(k8sClient.Create(ctx, trainJob)).Should(gomega.Succeed())
			})

			// Wait for jobs to become active
			ginkgo.By("Wait for TrainJob jobs to become active", func() {
				gomega.Eventually(func(g gomega.Gomega) {
					gotTrainJob := &trainer.TrainJob{}
					g.Expect(k8sClient.Get(ctx, client.ObjectKeyFromObject(trainJob), gotTrainJob)).Should(gomega.Succeed())
					g.Expect(gotTrainJob.Status.JobsStatus).Should(gomega.BeComparableTo([]trainer.JobStatus{
						{
							Name:      constants.Node,
							Ready:     ptr.To(int32(0)),
							Succeeded: ptr.To(int32(0)),
							Failed:    ptr.To(int32(0)),
							Active:    ptr.To(int32(1)),
							Suspended: ptr.To(int32(0)),
						},
					}, util.SortJobsStatus))
				}, util.TimeoutE2E, util.Interval).Should(gomega.Succeed())
			})

			// Wait for TrainJob to be in Succeeded status with all jobs succeeded.
			ginkgo.By("Wait for TrainJob to be in Succeeded status with all jobs succeeded", func() {
				gomega.Eventually(func(g gomega.Gomega) {
					gotTrainJob := &trainer.TrainJob{}
					g.Expect(k8sClient.Get(ctx, client.ObjectKeyFromObject(trainJob), gotTrainJob)).Should(gomega.Succeed())
					g.Expect(gotTrainJob.Status.Conditions).Should(gomega.BeComparableTo([]metav1.Condition{
						{
							Type:    trainer.TrainJobComplete,
							Status:  metav1.ConditionTrue,
							Reason:  jobsetconsts.AllJobsCompletedReason,
							Message: jobsetconsts.AllJobsCompletedMessage,
						},
					}, util.IgnoreConditions))
					g.Expect(gotTrainJob.Status.JobsStatus).Should(gomega.BeComparableTo([]trainer.JobStatus{
						{
							Name:      constants.Node,
							Ready:     ptr.To(int32(0)),
							Succeeded: ptr.To(int32(1)),
							Failed:    ptr.To(int32(0)),
							Active:    ptr.To(int32(0)),
							Suspended: ptr.To(int32(0)),
						},
					}, util.SortJobsStatus))
				}, util.TimeoutE2E, util.Interval).Should(gomega.Succeed())
			})
		})
	})

	ginkgo.When("Creating a TrainJob with PodTemplateOverrides", func() {
		ginkgo.It("should allow the user to set the manager field and default to 'Unknown' if empty", func() {
			trainJob := testingutil.MakeTrainJobWrapper(ns.Name, "e2e-test").
				RuntimeRef(trainer.SchemeGroupVersion.WithKind(trainer.ClusterTrainingRuntimeKind), torchRuntime).
				PodTemplateOverrides([]trainer.PodTemplateOverride{
					{
						TargetJobs: []trainer.PodTemplateOverrideTargetJob{{Name: constants.Node}},
						Spec: &trainer.PodTemplateSpecOverride{
							ServiceAccountName: ptr.To("test-sa-1"),
						},
					},
					{
						Manager:    ptr.To("kueue.k8s.io/manager"),
						TargetJobs: []trainer.PodTemplateOverrideTargetJob{{Name: constants.Node}},
						Spec: &trainer.PodTemplateSpecOverride{
							ServiceAccountName: ptr.To("test-sa-2"),
						},
					},
				}).
				Obj()

			ginkgo.By("Create a TrainJob with PodTemplateOverrides", func() {
				gomega.Expect(k8sClient.Create(ctx, trainJob)).Should(gomega.Succeed())
			})

			ginkgo.By("Verify manager field preserves user input and defaults to 'Unknown' if empty", func() {
				gomega.Eventually(func(g gomega.Gomega) {
					gotTrainJob := &trainer.TrainJob{}
					g.Expect(k8sClient.Get(ctx, client.ObjectKeyFromObject(trainJob), gotTrainJob)).Should(gomega.Succeed())
					g.Expect(gotTrainJob.Spec.PodTemplateOverrides).Should(gomega.HaveLen(2))
					g.Expect(*gotTrainJob.Spec.PodTemplateOverrides[0].Manager).To(gomega.Equal("trainer.kubeflow.org/unknown"))
					g.Expect(*gotTrainJob.Spec.PodTemplateOverrides[1].Manager).To(gomega.Equal("kueue.k8s.io/manager"))
				}, util.Timeout, util.Interval).Should(gomega.Succeed())
			})
		})
	})

	ginkgo.When("Creating TrainJob with progress tracking instrumentation", func() {
		ginkgo.It("should inject runtime configuration which allows the progress endpoint to be called", func() {
			// Create a TrainJob that sends a single progress update and exits
			trainJob := testingutil.MakeTrainJobWrapper(ns.Name, "e2e-test-progress").
				RuntimeRef(trainer.SchemeGroupVersion.WithKind(trainer.ClusterTrainingRuntimeKind), torchRuntime).
				Trainer(&trainer.Trainer{
					Command: []string{"python3", "-c"},
					Args:    []string{progressScript},
				}).
				Obj()

			ginkgo.By("Create a TrainJob with progress tracking", func() {
				gomega.Expect(k8sClient.Create(ctx, trainJob)).Should(gomega.Succeed())
			})

			ginkgo.By("Verify trainerStatus is updated with progress information", func() {
				gomega.Eventually(func(g gomega.Gomega) {
					gotTrainJob := &trainer.TrainJob{}
					g.Expect(k8sClient.Get(ctx, client.ObjectKeyFromObject(trainJob), gotTrainJob)).Should(gomega.Succeed())

					// Verify trainerStatus is not nil
					g.Expect(gotTrainJob.Status.TrainerStatus).ShouldNot(gomega.BeNil())

					// Verify progress percentage
					g.Expect(gotTrainJob.Status.TrainerStatus.ProgressPercentage).ShouldNot(gomega.BeNil())
					g.Expect(*gotTrainJob.Status.TrainerStatus.ProgressPercentage).Should(gomega.Equal(int32(42)))

					// Verify estimated remaining seconds
					g.Expect(gotTrainJob.Status.TrainerStatus.EstimatedRemainingSeconds).ShouldNot(gomega.BeNil())
					g.Expect(*gotTrainJob.Status.TrainerStatus.EstimatedRemainingSeconds).Should(gomega.Equal(int32(120)))

					// Verify metrics
					g.Expect(gotTrainJob.Status.TrainerStatus.Metrics).Should(gomega.HaveLen(2))
					g.Expect(gotTrainJob.Status.TrainerStatus.Metrics[0].Name).Should(gomega.Equal("loss"))
					g.Expect(gotTrainJob.Status.TrainerStatus.Metrics[0].Value).Should(gomega.Equal("0.123"))
					g.Expect(gotTrainJob.Status.TrainerStatus.Metrics[1].Name).Should(gomega.Equal("accuracy"))
					g.Expect(gotTrainJob.Status.TrainerStatus.Metrics[1].Value).Should(gomega.Equal("0.95"))

					// Verify lastUpdatedTime is set
					g.Expect(gotTrainJob.Status.TrainerStatus.LastUpdatedTime.IsZero()).Should(gomega.BeFalse())
				}, util.TimeoutE2E, util.Interval).Should(gomega.Succeed())
			})

			ginkgo.By("Wait for TrainJob to be in Succeeded status", func() {
				gomega.Eventually(func(g gomega.Gomega) {
					gotTrainJob := &trainer.TrainJob{}
					g.Expect(k8sClient.Get(ctx, client.ObjectKeyFromObject(trainJob), gotTrainJob)).Should(gomega.Succeed())
					g.Expect(gotTrainJob.Status.Conditions).Should(gomega.BeComparableTo([]metav1.Condition{
						{
							Type:    trainer.TrainJobComplete,
							Status:  metav1.ConditionTrue,
							Reason:  jobsetconsts.AllJobsCompletedReason,
							Message: jobsetconsts.AllJobsCompletedMessage,
						},
					}, util.IgnoreConditions))
				}, util.TimeoutE2E, util.Interval).Should(gomega.Succeed())
			})
		})
	})
})
